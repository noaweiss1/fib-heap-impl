
כאן יפורסמו במידת הצורך הבהרות לתרגיל

-- 01/06: בקריאה לmeld ניתן להניח שערכי הc של שתי הערימות הם זהים.

-- 08/06: בקובץ הטקסט info.txt נא לרשום את שמות המגישים בעברית וגם באנגלית.

-- 10/06: הבהרה שנועדה להקל עליכם. שורה תחתונה: מותר להשתמש ב ArrayList של ג'אווה לצורך הגדרת מערך ה"תאים" בעת ביצוע Successive linking (ולצורך זה בלבד).

פירוט: כזכור, כחלק מהפעולה DeleteMin יש לבצע Successive linking, במהלכו מגדירים מערך של "תאים" עבור כל דרגה אפשרית של עצים. בערימת פיבונאצ'י מספר הסלים הללו הוא לכל היותר logn לפי בסיס "פי", שכן זו הדרגה המקסימלית האפשרית בערימות מסוג זה. בתרגיל נדרשתם לממש מנגנון שתלוי בפרמטר c - מספר הילדים שאם נחתכו יגרור המשך חיתוך של ההורה. הפרמטר הזה - c - משפיע על הדרגה המקסימלית האפשרית בערימה: ככל ש c גדול יותר, הדרגה המקסימלית האפשרית גדולה יותר (מדוע?), ובהתאם גם מספר ה"תאים" הדרושים בעת successive linking גדול יותר.

מכיוון שלא ביקשנו מכם לחשב את הקשר הישיר בין ערכו של c לבין הדרגה המקסימילית האפשרית, עולה השאלה באיזה גודל נכון להגדיר את מערך התאים הנ"ל.

דרך פשוטה לעקוף את הבעיה היא להשתמש במערכים שגדלים בעת הצורך, כפי שלמדנו בתחילת הקורס. כלומר להגדיר מערך תאים בגודל כלשהו ולשנות את גודלו (למשל להכפילו) בעת הצורך. הסיבוכיות אמורטייזד של DeleteMin לא נפגעת, שכן ראינו שמנגנון של מערכים שגדלים בעת הצורך שומר על סיבוכיות קבועה אמורטייזד.

כדי להקל עליכם, אנחנו נרשה שימוש ב ArrayList של ג'אווה לצורך זה בלבד, שמממש בדיוק מנגנון כזה של מערכים שגדלים על פי צורך.

-- 12/06: לאחר ביצוע meld בין שתי ערימות נדרש להוסיף את כל הcuts והlinks של heap2 לערימה שאליה מבצעים את הmeld כי המשמעות של הcuts והlinks היא שמירה של תכונות של ההיסטוריה של הערימה ובmeld אנו מאחדים שתי ערימות לערימה אחת (ולכן רוצים לשמור את התכונות של ההיסטוריה ה"מאוחדת" שלה).

-- 12/06: כאשר אנחנו מבצעים delete min אנחנו מנתקים את הילדים של המינימום ומכניסים אותם לרשימת השורשים. במקרה הזה לא נוסיף את החיתוכים האלו למספר החיתוכים הכללי של הערימה.

-- 16/06: כאמור, אנו נרשה שימוש בArrayList לצורך הטיפול בסלים בdeleteMin בלבד. על מנת להקל עליכם וגם על הבודק, יש לרשום את שורת הקוד הבאה בתחילת הפעולה deleteMin:

java.util.ArrayList<Object> buckets = new java.util.ArrayList<>();

אין לבצע import לArrayList ולא לאף מחלקה אחרת שמממשת מבני נתונים בjava. האובייקט buckets שלעיל מוגדר להיות ArrayList של Object. הבנאי של ArrayList יכול (אבל לא חייב) לקבל כקלט את הגודל ההתחלתי של המערך שיוקצה. אם לא רושמים גודל התחלתי בבנאי (כמו במקרה שלנו) אז יש שימוש בגודל התחלתי דיפולטיבי. לגודל ההתחלתי של המערך אין משמעות ברמה האסימפטוטית על זמן הריצה של סדרת פעולות על המערך ולכן אין משמעות ברמה האסימפטוטית על זמן הריצה לשיעורין של פעולה בודדת על המערך.

-- 17/06: כאמור, כפי שאמיר פרסם, בגלל המצב התרגיל הזה הופך למגן ואין חובה להגישו.

-- 17/06: פרסמתי בפורום טסטר עבור המטלה שהבודק שלח לי.

